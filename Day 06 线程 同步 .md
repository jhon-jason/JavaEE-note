#线程

* 开启线程,为什么要继承Thread类?

Thread类就是线程类,继承Thread类,就具有了所有线程的方法.

* 为什么不直接创建Thread类的对象

直接创建Thread类, 无法重写 run方法, 无法执行我们需要运行的方法.

### Thread 类常用方法

`String getName()`  获取线程的名称

`void setName(String name) ` 设置线程名称

`static Thread currentThread()`  获取当前线程的线程对象, 在那个线程中调用,返回的就是那个线程的对象.

` static void sheep( long time )` 线程休眠 time 毫秒后 自动醒来 继续执行



## 线程创建的 第二种方式

### 实现Runnable 接口

1. 定义一个类 实现Runnable 接口
2. 重写 run方法
3. 开启线程  创建Runnable实现类对象, 创建参数为实现类的Thread对象
4. 调用start()方法,开启线程



为什么有第一个方式,还要有第二种方式

1. 实现接口,避免了单继承的局限性
2. 降低了耦合性-> 线程类和线程任务的耦合性->第一种方式线程类和线程任务耦合在一起

###匿名内部类 创建线程

**匿名内部类** 

* 作用 临时创建一个类的子类对象的快捷方式

* 格式 

  ```java 
   new 父类/接口(){
  			  重写方法
  		};
  ```

  ​

##线程的安全

当多条线程,同时操作同一个资源,就有可能出现线程错误,线程不安全.

### 线程同步

解决线程不安全的问题

####**同步代码块** 

--->解决数据不正确问题,但是降低了效率--->判断锁消耗资源

* **同步原理** 有锁的线程执行,没锁的线程等待.
* **一定注意锁的唯一性** 

```java
synchronized ( 任意对象 ){
	可能出现问题的代码
}
```

#### 同步方法

--->非静态的同步方法->锁是**this** 

* 同步方法可以是静态的,这是 锁是->当前类名.class

格式

```java
修饰符  synchronized 返回值类型 方法名 (参数){
  
}
```

### Lock--->接口

-->JDK1.5出现-->可以避免死锁

####常用方法

`lock()` 获得锁

`unlock` 释放锁

####常用实现类

ReentrantLock

## 线程的状态

| 线程状态                      | 说明                              |
| ------------------------- | :------------------------------ |
| NEW <br /> 新建             | 至今尚未启动的线程处于这种状态                 |
| RUNNABLE<br />可运行         | 正在 Java 虚拟机中执行的线程处于这种状态         |
| BLOCKED<br /> 锁阻塞         | 受阻塞并等待某个监视器锁的线程处于这种状态           |
| WAITING <br / >无限等待       | 无限期地等待另一个线程来执行某一特定操作的线程处于这种状态   |
| TIMED_WAITING  <br />计时等待 | 等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态 |
| TERMINATED<br />终止        | 已退出的线程处于这种状态                    |



![线程的状态](D:\Study\note\线程的状态.jpg)

sleep 和 wait的区别

sleep是Thread的方法 可以在同步中，也可以在同步外使用。如果在在同步中使用，sleep获得锁，不能释放锁对象

wait是Object类的方法，任何对象都可以调用此方法，因为所可以是任意对象，wait必须由锁对象调用，也就是说wait必须在同步中使用，当wait方法被调用，线程进入等待状态，这时线程会释放锁，当被notify唤醒后，当前线程没有锁，需要重新获得锁后才能进入同步中。



## 线程通信

* 多条线程同时操作一个资源，但是操作不同
* 想要多条线程协同合作，可以使用**等待唤醒机制** 