# 线程池

## 概述

### 为什么要存在

线程创建销毁会消耗大量系统资源,为了避免此现象,存在线程池.

### 合理使用线程池好处

1. 降低系统资源消耗
2. 提高响应速度
3. 提高线程可管理性,避免线程过多

### 线程池使用

常用方法

`static ExcutorService newFixedThreadPool(int nthreads) `创建指定线程数的线程池对象

` submit(Runnable task)` 提交线程任务

`Future submit( callable tesk)` 提交线程任务

返回的是Future类型对象,获取返回值方法为

get()



Rubnable 和Callable 区别

1. Runnable 没有返回值,Callable 有返回值
2. Runnable 没有抛异常,Callable抛出了Exception 其子类对象可以抛出任意异常.

# Lambda 表达式

###Lambda格式--标准格式

`( 参数类型 参数名称 )->{  方法体 } `

() 小括号内为方法的参数

-> 代表指向动作,把参数传给方法体

{} 方法体

### Lambda格式---省略格式

**可推导可省略**

1. 参数类型可以省略   (int a ,int b)  >>>>>   (a , b)
2. 如果只有一个参数,()可以省略   ( int  a)   >>>>   a
3. 如果方法体 只有一句话  {}  return 和 ; 可以同时省略,如果省略,必须同时省略

### Lambda 使用前提

1. 必须由接口, 并且接口中  **有且仅有一个抽象方法**
2. 方法的参数或者局部参数必须是Lambda对应的接口

> 接口中有且仅有一个抽象方法,称为函数式接口

## 函数式接口

### 定义

有且仅有一个抽象方法的接口(可以由其他方法:默认方法 静态方法,私有方法)

函数式接口一般作为方法的参数或者方法的返回值

@FunctionalInterface 验证是否为函数式接口

#### 常用的函数式接口

1. **Supplier**接口  ----供给型接口

   抽象方法为  `T get()  `  用来获取一个泛型参数指定类型的对象数据

2. **Consumer** 接口   -----消费型接口

   抽象方法为`void accept(T t)` 消费一个指定类型的数据

   默认方法 ` andthen` 

3. **Function**接口  -----类型转换

   抽象方法`R apply (T t)` 给定T 类型数据,返回R类型数据

   默认方法 `andthen` 

4. **Predicate**接口-- 判断

   抽象方法为`boolean test( T t ) `判断方法

   默认方法

   | and        | 并且     | &&       |
   | ---------- | ------ | -------- |
   | **or**     | **或者** | **\|\|** |
   | **negate** | **非**  | **!**    |

   ​

